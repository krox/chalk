#pragma once

/**
 * Multivariate polynomials with fixed type of coefficients and all strings
 * as possible variables. Implemented using util::string_id to remove the
 * overhead of passing actual strings around.
 *
 * Compared to chalk::SparsePolynomial
 *     - Does not need or use an explcit `PolynomialRing` type, which makes it
 *       easier to use. In particular, there is no need to specify a 'rank'.
 *     - Performance implications are unclear. Should do some benchmarks, though
 *       it probably depends on usecase (and on the parameters of the
 *       small-buffer-optimizations).
 *     - It is impossible to specify a term order. The one used is "degrevlex"
 *       with variable ordering depending on the (usually accidental) internal
 *       order of strings inside the StringPool instance.
 *       Rational: The term-order only really matters for advanced algorithms
 *                 (such as computing Groebner basis), which probably should
 *                 do their own thing anyway.
 *     - This class can be implemented as a specialization of
 *       chalk::Multinomial (which should be renamed to something like
 *       'MonoidRing'), which is really nice.
 */

#include "chalk/group_ring.h"
#include "chalk/parser.h"
#include "chalk/polynomial.h"
#include "chalk/rings.h"
#include "fmt/format.h"
#include "util/string_id.h"
#include "util/vector.h"
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <map>
#include <optional>
#include <span>
#include <utility>
#include <vector>

namespace chalk {

// Will be moved to more global position if more modules use it. Might
// facilitate easier conversion like Polynomial <-> Symbolic for example.
inline util::StringPool symbol_pool;

// free abelian monoid, generated by non-empty strings
class SymbolMonoid
{
	// 16-bit string_id + 16-bit exponent makes this very compact and very
	// usable with small_vector. Though the number 3 is kinda arbitrary.
  public:
	using exponent_type = int16_t;
	using symbol_type = util::string_id;
	using terms_type =
	    util::small_vector<std::pair<symbol_type, exponent_type>, 3>;

  private:
	terms_type terms_;

	void cleanup()
	{
		std::sort(terms_.begin(), terms_.end(),
		          [](auto a, auto b) { return a.first.id() < b.first.id(); });
		size_t j = 0;
		for (size_t i = 0; i < terms_.size(); ++i)
		{
			// if index == previous index -> join
			if (j != 0 && terms_[j - 1].first == terms_[i].first)
				terms_[j - 1].second += terms_[i].second;

			// else new term
			else if (i != j)
				terms_[j++] = terms_[i];
			else
				j++;

			// if coeff = 0 -> remove term
			assert(j);
			if (terms_[j - 1].second == 0)
				--j;
		}
		terms_.resize(j);
	}

  public:
	SymbolMonoid() = default;

	SymbolMonoid(terms_type t) : terms_(std::move(t)) { cleanup(); }
	SymbolMonoid(util::string_id s) : terms_({{s, 1}}) {}
	SymbolMonoid(std::string_view s) : SymbolMonoid(symbol_pool(s)) {}
	SymbolMonoid(int v) { assert(v == 1); }

	static SymbolMonoid generator(std::string_view s)
	{
		return SymbolMonoid(s);
	}

	terms_type const &terms() const { return terms_; }

	friend bool operator==(SymbolMonoid const &,
	                       SymbolMonoid const &) = default;
	friend auto operator<=>(SymbolMonoid const &,
	                        SymbolMonoid const &) = default;
};

inline SymbolMonoid operator*(SymbolMonoid const &a, SymbolMonoid const &b)
{
	SymbolMonoid::terms_type c;
	c.reserve(a.terms().size() + b.terms().size());
	c.insert(c.end(), a.terms().begin(), a.terms().end());
	c.insert(c.end(), b.terms().begin(), b.terms().end());
	return SymbolMonoid(std::move(c));
}

inline bool operator==(SymbolMonoid const &a, int b)
{
	assert(b == 1);
	return a.terms().empty();
}

/*inline bool operator==(SymbolMonoid const &a, SymbolMonoid const &b)
{
    return a.terms() == b.terms();
}
inline bool operator<(SymbolMonoid const &a, SymbolMonoid const &b)
{
    return a.terms() < b.terms();
}*/

template <typename R> using DynamicPolynomial = Multinomial<R, SymbolMonoid>;

} // namespace chalk

template <> struct fmt::formatter<chalk::SymbolMonoid>
{
	constexpr auto parse(format_parse_context &ctx) { return ctx.begin(); }

	template <typename FormatContext>
	auto format(const chalk::SymbolMonoid &word, FormatContext &ctx)
	    -> decltype(ctx.out())
	{
		// empty word -> "1"
		if (word.terms().empty())
			return fmt::format_to(ctx.out(), "1");

		// otherwise list the terms with " * " inbetween
		auto it = ctx.out();
		for (size_t i = 0; i < word.terms().size(); ++i)
		{
			if (i != 0)
				it = fmt::format_to(it, "*");
			it = fmt::format_to(it, "{}",
			                    chalk::symbol_pool(word.terms()[i].first));
			if (word.terms()[i].second != 1)
				it = fmt::format_to(it, "^{}", word.terms()[i].second);
		}
		return it;
	}
};
